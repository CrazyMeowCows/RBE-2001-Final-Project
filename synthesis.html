<!DOCTYPE html>
<head><title>Linkage Synthesis</title></head>

<canvas id="canvas" width="1400" height="950"></canvas>    

<script>
    var canvas = document.getElementById('canvas')
    var ctx = canvas.getContext("2d");
    ctx.translate(10, -10);

    //Utils--------------------------------------------------------------------
    function circle(x, y, r, doOutline) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, 2*Math.PI, false);
        ctx.fill();
        if (doOutline) ctx.stroke();
    }
    function line(x, y, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }

    function rad (deg) {
        return deg*PI/180
    }
    function Wheel (x, y, rad, rot, minRotDeg) {
        this.x = x;
        this.y = y;
        
        this.rad = rad;
        this.rot = rot;
        this.minRotDeg = minRotDeg;

        this.updatePivot = ()=>{
            this.pivotX = this.x+Math.cos(this.rot)*this.rad;
            this.pivotY = this.y+Math.sin(this.rot)*this.rad;
        }
        this.updatePivot();
    }

    //Constants----------------------------------------------------------------
    const W = 1400;
    const H = 950;

    const pxPerMM = 1400/500;
    const shelfDepth_mm = 60;
    const pivotRad_px = 15;

    const PI = Math.PI;
    const linkageW_px = 20;

    const targetX = shelfDepth_mm-25/2;
    const targetYPoints = [25/2, 182+25/2, 224+25/2, 266+25/2];
    
    var targetScores = [999, 999, 999, 999];
    var prevSystemScore = 999;
    var stopIterating = false;

    var colors = ["blue", "cyan" , "orange", "purple"];
    var colorIterator = 0;

    //System Variables----------------------------------------------------------------
    function System (wheel1, wheel2, lengthA, lengthB, lengthATotal) {
        this.wheel1 = wheel1;
        this.wheel2 = wheel2;
        this.lengthA = lengthA;
        this.lengthB = lengthB;
        this.lengthATotal = lengthATotal;
    }

    // var bestSystem = new System(new Wheel(350, 100, 30, 0), new Wheel(400, 150, 30, 0), 100, 60, 300);
    // var bestSystem = new System(new Wheel(378, 147, 73.5, 0), new Wheel(391, 109, 42, 0), 99, 64, 331);
    // var bestSystem = new System(new Wheel(331, 116.6, 30, 0), new Wheel(406, 136.9, 36.6, 0), 91, 48.9, 345.2); //Long linkage
    // var bestSystem = new System(new Wheel(331, 116.6, 40, 0), new Wheel(406, 136.9, 36.6, 0), 91, 48.9, 345.2); //Long linkage Mod1
    // var bestSystem = new System(new Wheel(331, 116.6, 30, 0), new Wheel(406, 136.9, 36.6, 0), 91, 40, 345.2); //Long linkage Mod2
    // var bestSystem = new System(new Wheel(263.7, 89.1, 40.5, 0), new Wheel(380, 139.4, 54, 0), 93, 48.6, 308); //Short Linkage
    // var bestSystem = new System(new Wheel(301.6, 137.6, 60, 0, 212), new Wheel(406, 136.9, 36.6, 0, 65.8), 67, 47, 355.7); //Long linkage Mod1
    // var bestSystem = new System(new Wheel(444.8657345136502+60,149.99925091216508,34.96173326719975,5.299397048828742,183.3119478844981), 
                                // new Wheel(367.9201470815851+60,155.3113749964786,37.7990874376663,2.1000000000000005,0),40.53289637598182,107.2711047565303,379.1209913495621);
var bestSystem = new System(new Wheel(329.8+35,129.4-25,60,5.4,191.9), new Wheel(319.4+35,180.6-25,38.2,6.3,191.9),68,109.8,293.6);    



function getRandom() {
        return (Math.random()-0.5)*15;
    }
    function clamp(x, min, max) {
        return Math.max(Math.min(x, max), min);
    }

    function mutateSystem(system) {
        system.wheel1.x += getRandom();
        system.wheel1.y += getRandom();
        system.wheel1.rad += getRandom();
        system.wheel2.x += getRandom();
        system.wheel2.y += getRandom();
        system.wheel2.rad += getRandom();

        system.lengthA += getRandom();
        system.lengthB += getRandom();
        system.lengthATotal += getRandom();

        system.wheel1.rad = clamp(system.wheel1.rad, 30, 150)
        system.wheel2.rad = clamp(system.wheel2.rad, 30, 150)
        system.lengthA = clamp(system.lengthA, 30, 200)
        system.lengthB = clamp(system.lengthB, 30, 200)
        system.lengthATotal = clamp(system.lengthATotal, 30, 1000)
    }

    function iterateSystem(system) {
        for(system.wheel1.rot = 0; system.wheel1.rot <= PI*2; system.wheel1.rot += 0.1) {
            for(system.wheel2.rot = 0; system.wheel2.rot <= PI*2; system.wheel2.rot += 0.1) {
                updateKinematics(system, true);
                renderSystem(system, true);
            }
        }
    }

    function scoreLastIteratedSystem(system) {
        return targetScores.reduce((acc, curr) => acc + curr, 0);
    }

    //Kinematic References
    function updateKinematics (sys, setBestScores) {
        sys.wheel1.updatePivot();
        sys.wheel2.updatePivot();

        let c = Math.hypot(sys.wheel1.pivotX-sys.wheel2.pivotX, sys.wheel1.pivotY-sys.wheel2.pivotY);
        let thetaInterior = Math.acos((sys.lengthB*sys.lengthB-sys.lengthA*sys.lengthA-c*c)/(-2*sys.lengthA*c)); 
        let thetaReference = Math.atan2(sys.wheel1.pivotY-sys.wheel2.pivotY, sys.wheel1.pivotX-sys.wheel2.pivotX);
        let thetaLinkage = thetaReference-thetaInterior;
        sys.linkagePivotX = sys.wheel2.pivotX+Math.cos(thetaLinkage)*sys.lengthA;
        sys.linkagePivotY = sys.wheel2.pivotY+Math.sin(thetaLinkage)*sys.lengthA;

        sys.linkageEndpointX = sys.wheel2.pivotX+Math.cos(thetaLinkage)*sys.lengthATotal;
        sys.linkageEndpointY = sys.wheel2.pivotY+Math.sin(thetaLinkage)*sys.lengthATotal;

        for(let y in targetYPoints) {
            if (setBestScores) {
                if (isNaN(sys.linkageEndpointX+sys.linkageEndpointY)) return;
                targetScores[y] = Math.min(targetScores[y], Math.hypot(sys.linkageEndpointX-targetX, sys.linkageEndpointY-targetYPoints[y]));
            } else {
                if (Math.hypot(sys.linkageEndpointX-targetX, sys.linkageEndpointY-targetYPoints[y]) == targetScores[y]) 
                renderSystem(sys, false);
            }
        }
    }

    //Drawing------------------------------------------------------------------
    function renderSystem(sys, onlyShowEndpoint) {
        if (onlyShowEndpoint) {
            if (sys.wheel1.rot > rad(sys.wheel1.minRotDeg+120) || sys.wheel1.rot < rad(sys.wheel1.minRotDeg)) return;
            if (sys.wheel2.rot > rad(sys.wheel2.minRotDeg+120) || sys.wheel2.rot < rad(sys.wheel2.minRotDeg)) return;
            ctx.lineWidth = 2*pxPerMM;
            ctx.strokeStyle = "lightgray";
            ctx.fillStyle = "lightgray";
            circle(sys.linkageEndpointX*pxPerMM, H-sys.linkageEndpointY*pxPerMM, pivotRad_px, true);
            return;
        }

        ctx.globalAlpha = 0.5;
        ctx.strokeStyle = colors[colorIterator];
        ctx.lineWidth = linkageW_px;
        line(sys.wheel2.pivotX*pxPerMM, H-sys.wheel2.pivotY*pxPerMM, sys.linkageEndpointX*pxPerMM, H-sys.linkageEndpointY*pxPerMM);
        line(sys.wheel1.pivotX*pxPerMM, H-sys.wheel1.pivotY*pxPerMM, sys.linkagePivotX*pxPerMM, H-sys.linkagePivotY*pxPerMM);
        ctx.globalAlpha = 1;

        ctx.lineWidth = 2*pxPerMM;
        ctx.strokeStyle = "black";
        ctx.fillStyle = colors[colorIterator];
                colorIterator++;

        circle(sys.wheel1.pivotX*pxPerMM, H-sys.wheel1.pivotY*pxPerMM, pivotRad_px, true);
        circle(sys.wheel2.pivotX*pxPerMM, H-sys.wheel2.pivotY*pxPerMM, pivotRad_px, true);
        circle(sys.linkagePivotX*pxPerMM, H-sys.linkagePivotY*pxPerMM, pivotRad_px, true);
        circle(sys.linkageEndpointX*pxPerMM, H-sys.linkageEndpointY*pxPerMM, pivotRad_px, true);

        ctx.fillStyle = "lime";
        for(let y in targetYPoints) {
            circle(targetX*pxPerMM, H-targetYPoints[y]*pxPerMM, 25/2*pxPerMM, true);
        }
    }

    ctx.strokeStyle = "black";
    ctx.fillStyle = "red";
    circle(bestSystem.wheel1.x*pxPerMM, H-bestSystem.wheel1.y*pxPerMM, bestSystem.wheel1.rad*pxPerMM, true);
    ctx.fillStyle = "green";
    circle(bestSystem.wheel2.x*pxPerMM, H-bestSystem.wheel2.y*pxPerMM, bestSystem.wheel2.rad*pxPerMM, true);
    ctx.fillStyle = "black";
    circle(bestSystem.wheel1.x*pxPerMM, H-bestSystem.wheel1.y*pxPerMM, pivotRad_px/3, true);
    circle(bestSystem.wheel2.x*pxPerMM, H-bestSystem.wheel2.y*pxPerMM, pivotRad_px/3, true);
    

    iterateSystem(bestSystem);

    for(bestSystem.wheel1.rot = 0; bestSystem.wheel1.rot <= PI*2; bestSystem.wheel1.rot += 0.1) {
        for(bestSystem.wheel2.rot = 0; bestSystem.wheel2.rot <= PI*2; bestSystem.wheel2.rot += 0.1) {
            updateKinematics(bestSystem, false);
        }
    }

    ctx.strokeStyle = "brown";
    ctx.lineWidth = 2*pxPerMM;
    line(0, H, 0, H-264*pxPerMM)
    line(0, H, shelfDepth_mm*pxPerMM, H)
    line(0, H-181*pxPerMM, shelfDepth_mm*pxPerMM, H-181*pxPerMM)
    line(0, H-223*pxPerMM, shelfDepth_mm*pxPerMM, H-223*pxPerMM)
    line(0, H-264*pxPerMM, shelfDepth_mm*pxPerMM, H-264*pxPerMM)
</script>