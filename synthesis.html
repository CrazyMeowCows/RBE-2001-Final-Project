<!DOCTYPE html>
<head><title>Linkage Synthesis</title></head>

<canvas id="canvas" width="1400" height="950"></canvas>    

<script>
    var canvas = document.getElementById('canvas')
    var ctx = canvas.getContext("2d");
    ctx.translate(10, -10);

    //Utils--------------------------------------------------------------------
    function circle(x, y, r, doOutline) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, 2*Math.PI, false);
        ctx.fill();
        if (doOutline) ctx.stroke();
    }
    function line(x, y, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
    function lerp (x, y, i) {
        return x * (1 - i) + y * i;
    }
    function Wheel (x, y, rad, rot) {
        this.x = x;
        this.y = y;
        
        this.rad = rad;
        this.rot = rot;

        this.updatePivot = ()=>{
            this.pivotX = this.x+Math.cos(this.rot)*this.rad;
            this.pivotY = this.y+Math.sin(this.rot)*this.rad;
        }
        this.updatePivot();
    }
    function Point (x, y) {
        this.x = x;
        this.y = y;
    }

    //Constants----------------------------------------------------------------
    const W = 1400;
    const H = 950;

    const pxPerMM = 1400/500;
    const shelfDepth_mm = 60;
    const pivotRad_px = 15;
    const boxSize_mm = 25;

    const PI = Math.PI;
    const linkageW_px = 20;

    const targetX = shelfDepth_mm-25/2;
    const targetYPoints = [boxSize_mm/2, 182+boxSize_mm/2, 224+boxSize_mm/2, 266+boxSize_mm/2];

    const keyframeX = shelfDepth_mm+boxSize_mm;
    const keyframeYPoints = [boxSize_mm/2, 182+boxSize_mm/2, 224+boxSize_mm/2, 266+boxSize_mm/2];

    const targetPoints = [
        new Point(targetX, targetYPoints[0]), //0
        new Point(targetX, targetYPoints[1]), 
        new Point(targetX, targetYPoints[2]), 
        new Point(targetX, targetYPoints[3]),
        new Point(keyframeX, keyframeYPoints[0]), //4
        new Point(keyframeX, keyframeYPoints[1]), 
        new Point(keyframeX, keyframeYPoints[2]), 
        new Point(keyframeX, keyframeYPoints[3]), 
    ];

    var generatedAnimPoints = [];

    const keyframes = [
        0,
        4,
        5,
        1,
        5,
        6,
        2,
        6,
        7,
        3,
    ];
    var sysAtPoints = Array(targetPoints.length);
    var currentKeyframe = 0;
    var interpolation = 0;
    
    var targetScores = [];

    //System Variables----------------------------------------------------------------
    function System (wheel1, wheel2, lengthA, lengthB, lengthATotal) {
        this.wheel1 = wheel1;
        this.wheel2 = wheel2;
        this.lengthA = lengthA;
        this.lengthB = lengthB;
        this.lengthATotal = lengthATotal;
    }

    // var bestSystem = new System(new Wheel(350, 100, 30, 0), new Wheel(400, 150, 30, 0), 100, 60, 300);
    // var bestSystem = new System(new Wheel(378, 147, 73.5, 0), new Wheel(391, 109, 42, 0), 99, 64, 331);
    // var bestSystem = new System(new Wheel(331, 116.6, 30, 0), new Wheel(406, 136.9, 36.6, 0), 91, 48.9, 345.2); //Long linkage
    var system = new System(new Wheel(331, 116.6, 40, 0), new Wheel(406, 136.9, 36.6, 0), 91, 48.9, 345.2); //Long linkage Mod1
    // var bestSystem = new System(new Wheel(331, 116.6, 30, 0), new Wheel(406, 136.9, 36.6, 0), 91, 40, 345.2); //Long linkage Mod2
    // var bestSystem = new System(new Wheel(263.7, 89.1, 40.5, 0), new Wheel(380, 139.4, 54, 0), 93, 48.6, 308); //Short Linkage

    function findSysAtPoints(system) {
        for(system.wheel1.rot = 0; system.wheel1.rot <= PI*2; system.wheel1.rot += 0.1) {
            for(system.wheel2.rot = 0; system.wheel2.rot <= PI*2; system.wheel2.rot += 0.1) {
                updateKinematics(system, "findScores");
            }
        }
        for(system.wheel1.rot = 0; system.wheel1.rot <= PI*2; system.wheel1.rot += 0.1) {
            for(system.wheel2.rot = 0; system.wheel2.rot <= PI*2; system.wheel2.rot += 0.1) {
                updateKinematics(system, "findSysAtPoints");
            }
        }
    }

    function interpolateSystems(sys1, sys2, i) {
        let iSys = {...system};
        iSys.wheel1.rot = lerp(sys1.wheel1.rot, sys2.wheel1.rot, i);
        iSys.wheel2.rot = lerp(sys1.wheel2.rot, sys2.wheel2.rot, i);
        updateKinematics(iSys, "none");
        return iSys;
    }
    function interpolatePoints(p1, p2, i) {
        return new Point(lerp(p1.x, p2.x, i), lerp(p1.y, p2.y, i));
    }

    function updateKinematics (sys, mode) {
        sys.wheel1.updatePivot();
        sys.wheel2.updatePivot();

        let c = Math.hypot(sys.wheel1.pivotX-sys.wheel2.pivotX, sys.wheel1.pivotY-sys.wheel2.pivotY);
        let thetaInterior = Math.acos((sys.lengthB*sys.lengthB-sys.lengthA*sys.lengthA-c*c)/(-2*sys.lengthA*c)); 
        let thetaReference = Math.atan2(sys.wheel1.pivotY-sys.wheel2.pivotY, sys.wheel1.pivotX-sys.wheel2.pivotX);
        let thetaLinkage = thetaReference-thetaInterior;
        sys.linkagePivotX = sys.wheel2.pivotX+Math.cos(thetaLinkage)*sys.lengthA;
        sys.linkagePivotY = sys.wheel2.pivotY+Math.sin(thetaLinkage)*sys.lengthA;

        sys.linkageEndpointX = sys.wheel2.pivotX+Math.cos(thetaLinkage)*sys.lengthATotal;
        sys.linkageEndpointY = sys.wheel2.pivotY+Math.sin(thetaLinkage)*sys.lengthATotal;

        for(let i in generatedAnimPoints) {
            if (mode == "findScores") {
                if (isNaN(sys.linkageEndpointX+sys.linkageEndpointY)) return;
                targetScores[i] = Math.min(targetScores[i], Math.hypot(sys.linkageEndpointX-generatedAnimPoints[i].x, sys.linkageEndpointY-generatedAnimPoints[i].y));
            } else if (mode == "findSysAtPoints") {
                if (Math.hypot(sys.linkageEndpointX-generatedAnimPoints[i].x, sys.linkageEndpointY-generatedAnimPoints[i].y) == targetScores[i]) {
                    sysAtPoints[i] = JSON.parse(JSON.stringify(sys));
                }
            }
        }
    }

    //Drawing------------------------------------------------------------------
    function renderSystem(sys) {
        ctx.clearRect(0, 0, W, H);

        //Draw the wheels
        ctx.strokeStyle = "black";
        ctx.fillStyle = "red";
        circle(sys.wheel1.x*pxPerMM, H-sys.wheel1.y*pxPerMM, sys.wheel1.rad*pxPerMM, true);
        ctx.fillStyle = "green";
        circle(sys.wheel2.x*pxPerMM, H-sys.wheel2.y*pxPerMM, sys.wheel2.rad*pxPerMM, true);
        ctx.fillStyle = "black";
        circle(sys.wheel1.x*pxPerMM, H-sys.wheel1.y*pxPerMM, pivotRad_px/3, true);
        circle(sys.wheel2.x*pxPerMM, H-sys.wheel2.y*pxPerMM, pivotRad_px/3, true);

        //Set the color
        ctx.strokeStyle = "cyan";
        ctx.fillStyle = "cyan";

        //Draw the linkages
        ctx.globalAlpha = 0.5;
        ctx.lineWidth = linkageW_px;
        line(sys.wheel2.pivotX*pxPerMM, H-sys.wheel2.pivotY*pxPerMM, sys.linkageEndpointX*pxPerMM, H-sys.linkageEndpointY*pxPerMM);
        line(sys.wheel1.pivotX*pxPerMM, H-sys.wheel1.pivotY*pxPerMM, sys.linkagePivotX*pxPerMM, H-sys.linkagePivotY*pxPerMM);
        ctx.globalAlpha = 1;

        //Draw the pivots
        ctx.lineWidth = 2*pxPerMM;
        ctx.strokeStyle = "black";
        circle(sys.wheel1.pivotX*pxPerMM, H-sys.wheel1.pivotY*pxPerMM, pivotRad_px, true);
        circle(sys.wheel2.pivotX*pxPerMM, H-sys.wheel2.pivotY*pxPerMM, pivotRad_px, true);
        circle(sys.linkagePivotX*pxPerMM, H-sys.linkagePivotY*pxPerMM, pivotRad_px, true);
        circle(sys.linkageEndpointX*pxPerMM, H-sys.linkageEndpointY*pxPerMM, pivotRad_px, true);

        //Draw the targets and keyframes
        ctx.fillStyle = "red";
        for(let y in targetYPoints) {
            ctx.fillRect((targetX-boxSize_mm/2)*pxPerMM, H-(targetYPoints[y]+boxSize_mm/2)*pxPerMM, boxSize_mm*pxPerMM, boxSize_mm*pxPerMM);
        }
        ctx.fillStyle = "lime";
        for(let y in keyframeYPoints) {
            circle(keyframeX*pxPerMM, H-keyframeYPoints[y]*pxPerMM, 10, true);
        }

        //Draw the shelf
        ctx.strokeStyle = "brown";
        ctx.lineWidth = 2*pxPerMM;
        line(0, H, 0, H-264*pxPerMM)
        line(0, H, shelfDepth_mm*pxPerMM, H)
        line(0, H-181*pxPerMM, shelfDepth_mm*pxPerMM, H-181*pxPerMM)
        line(0, H-223*pxPerMM, shelfDepth_mm*pxPerMM, H-223*pxPerMM)
        line(0, H-264*pxPerMM, shelfDepth_mm*pxPerMM, H-265*pxPerMM)
    }

    function generateAnimPoints() {
        let newPoint = interpolatePoints(targetPoints[keyframes[currentKeyframe]], targetPoints[keyframes[currentKeyframe+1]], interpolation);
        generatedAnimPoints.push(newPoint);
        targetScores.push(999);

        interpolation += 0.01;
        if(interpolation > 1) {
            interpolation = 0;
            currentKeyframe++;
        }
        if (currentKeyframe < keyframes.length-1) generateAnimPoints();
    }
    generateAnimPoints();
    currentKeyframe = 0;

    findSysAtPoints(system);

    console.log("Done")

    function animate() {
        let sys = interpolateSystems(sysAtPoints[currentKeyframe], sysAtPoints[currentKeyframe+1], interpolation);
        renderSystem(sys);
        // console.log(sys)

        // interpolation += 0.01;
        // if(interpolation >= 1) {
        //     interpolation = 0;
            currentKeyframe++;
        // }
        if (currentKeyframe >= sysAtPoints.length-1) currentKeyframe = 0;
        requestAnimationFrame(animate);
    }
    animate();
</script>