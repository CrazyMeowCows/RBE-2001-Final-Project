<!DOCTYPE html>
<head><title>Inverse Kinematics</title></head>

<canvas id="canvas" width="1400" height="950"></canvas>    

<script>
    var canvas = document.getElementById('canvas')
    var ctx = canvas.getContext("2d");
    ctx.translate(10, -10);


    //Utils--------------------------------------------------------------------
    function lerp (x, y, i) {
        return x * (1 - i) + y * i;
    }
    function rad (deg) {
        return deg*PI/180
    }
    function interpolatePoints(p1, p2, i) {
        return new Point(lerp(p1.x, p2.x, i), lerp(p1.y, p2.y, i));
    }
    function dist(p1, p2) {
        return Math.hypot(p2.x - p1.x, p2.y - p1.y);
    }


    //Objects------------------------------------------------------------------
    function Point (x, y) {
        this.x = x;
        this.y = y;

        this.test = function() {
            return "a";
        }
    }
    function Wheel (origin, rad, rot, minRotDeg) {
        this.origin = origin;
        this.pivot = null;
        this.rad = rad;
        this.rot = rot;
        this.minRotDeg = minRotDeg;
    }
    function System (wheel1, wheel2, lengthA, lengthB, lengthATotal) {
        this.wheel1 = wheel1;
        this.wheel2 = wheel2;
        this.lengthA = lengthA;
        this.lengthB = lengthB;
        this.lengthATotal = lengthATotal;
    }


    //Constants----------------------------------------------------------------
    const W = 1400;
    const H = 950;

    const pxPerMM = 1400/500;
    const shelfDepth_mm = 60;
    const pivotRad_px = 15;
    const boxSize_mm = 25;

    const PI = Math.PI;
    const linkageW_px = 20;

    const targetPoints = [
        new Point(shelfDepth_mm-25/2, boxSize_mm/2), //0
        new Point(shelfDepth_mm-25/2, 182+boxSize_mm/2), 
        new Point(shelfDepth_mm-25/2, 224+boxSize_mm/2), 
        new Point(shelfDepth_mm-25/2, 266+boxSize_mm/2),
        new Point(shelfDepth_mm+boxSize_mm, boxSize_mm/2), //4
        new Point(shelfDepth_mm+boxSize_mm, 182+boxSize_mm/2), 
        new Point(shelfDepth_mm+boxSize_mm, 224+boxSize_mm/2), 
        new Point(shelfDepth_mm+boxSize_mm, 266+boxSize_mm/2), 
    ];
    const keyframes = [0,4,5,1,5,6,2,6,7,3,];
    

    //System Variables---------------------------------------------------------
    var sys = new System(new Wheel(new Point(336,102.1),53.8,4.5,139.3), new Wheel(new Point(375.3,125.1),50.3,2.7,33.3),63.7,88.8,323.1);
    var currentKeyframe = 0;
    var interpolation = 0;


    //Inverse kinematics-------------------------------------------------------
    //Sourced from https://stackoverflow.com/questions/12219802/a-javascript-function-that-returns-the-x-y-points-of-intersection-between-two-ci
    function findIntersection (p1, r1, p2, r2) {
        let dx = p2.x - p1.x;
        let dy = p2.y - p1.y;

        let d = dist(p1, p2);
        let a = (r1*r1 - r2*r2 + d*d) / (2.0*d) ;

        let x2 = p1.x + (dx * a/d);
        let y2 = p1.y + (dy * a/d);

        let h = Math.sqrt(r1*r1 - a*a);

        let rx = -dy * (h/d);
        let ry = dx * (h/d);

        let xi = x2 + rx;
        let xi_prime = x2 - rx;
        let yi = y2 + ry;
        let yi_prime = y2 - ry;

        return [new Point(xi, yi), new Point(xi_prime, yi_prime)];
    }

    function runIK() {
        let target = interpolatePoints(targetPoints[keyframes[currentKeyframe]], targetPoints[keyframes[currentKeyframe+1]], interpolation);
        
        sys.linkageEndpoint = target;
        sys.wheel2.pivot = findIntersection(target, sys.lengthATotal, sys.wheel2.origin, sys.wheel2.rad)[0];
        
        let thetaLinkage = Math.atan2(sys.linkageEndpoint.y-sys.wheel2.pivot.y, sys.linkageEndpoint.x-sys.wheel2.pivot.x);
        let linkagePivotX = sys.wheel2.pivot.x+Math.cos(thetaLinkage)*sys.lengthA;
        let linkagePivotY = sys.wheel2.pivot.y+Math.sin(thetaLinkage)*sys.lengthA;
        sys.linkagePivot = new Point(linkagePivotX, linkagePivotY);
        sys.wheel1.pivot = findIntersection(sys.linkagePivot, sys.lengthB, sys.wheel1.origin, sys.wheel1.rad)[1];
        
        renderSystem(sys);

        interpolation += 1/dist(targetPoints[keyframes[currentKeyframe]], targetPoints[keyframes[currentKeyframe+1]]);
        if(interpolation >= 1) {
            interpolation = 0;
            currentKeyframe++;
        }
        if (currentKeyframe >= keyframes.length-1) currentKeyframe = 0;
        requestAnimationFrame(runIK);
    }
    runIK();


    //Drawing------------------------------------------------------------------
    function circle(x, y, r, doOutline) {
        ctx.beginPath();
        ctx.arc(x*pxPerMM, H-y*pxPerMM, r, 0, 2*Math.PI, false);
        ctx.fill();
        if (doOutline) ctx.stroke();
    }
    function line(x, y, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x*pxPerMM, H-y*pxPerMM);
        ctx.lineTo(x2*pxPerMM, H-y2*pxPerMM);
        ctx.stroke();
    }

    function renderSystem(sys) {
        ctx.clearRect(0, 0, W, H);

        //Draw the wheels
        ctx.strokeStyle = "black";
        ctx.fillStyle = "red";
        circle(sys.wheel1.origin.x, sys.wheel1.origin.y, sys.wheel1.rad*pxPerMM, true);
        ctx.fillStyle = "green";
        circle(sys.wheel2.origin.x, sys.wheel2.origin.y, sys.wheel2.rad*pxPerMM, true);
        ctx.fillStyle = "black";
        circle(sys.wheel1.origin.x, sys.wheel1.origin.y, pivotRad_px/3, true);
        circle(sys.wheel2.origin.x, sys.wheel2.origin.y, pivotRad_px/3, true);

        //Set the color
        ctx.strokeStyle = "cyan";
        ctx.fillStyle = "cyan";

        //Draw the linkages
        ctx.globalAlpha = 0.5;
        ctx.lineWidth = linkageW_px;
        line(sys.wheel2.pivot.x, sys.wheel2.pivot.y, sys.linkageEndpoint.x, sys.linkageEndpoint.y);
        line(sys.wheel1.pivot.x, sys.wheel1.pivot.y, sys.linkagePivot.x, sys.linkagePivot.y);
        ctx.globalAlpha = 1;

        //Draw the pivots
        ctx.lineWidth = 2*pxPerMM;
        ctx.strokeStyle = "black";
        circle(sys.wheel1.pivot.x, sys.wheel1.pivot.y, pivotRad_px, true);
        circle(sys.wheel2.pivot.x, sys.wheel2.pivot.y, pivotRad_px, true);
        circle(sys.linkagePivot.x, sys.linkagePivot.y, pivotRad_px, true);
        circle(sys.linkageEndpoint.x, sys.linkageEndpoint.y, pivotRad_px, true);

        //Draw the targets and keyframes
        ctx.fillStyle = "lime";
        for(let i in targetPoints) {
            circle(targetPoints[i].x, targetPoints[i].y, 10, true);
        }

        //Draw the shelf
        ctx.strokeStyle = "brown";
        ctx.lineWidth = 2*pxPerMM;
        line(0, 0, 0, 264)
        line(0, 0, shelfDepth_mm, 0)
        line(0, 181, shelfDepth_mm, 181)
        line(0, 223, shelfDepth_mm, 223)
        line(0, 264, shelfDepth_mm, 265)
    }
</script>