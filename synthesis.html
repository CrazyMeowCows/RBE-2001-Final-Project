<!DOCTYPE html>
<head><title>Linkage Synthesis</title></head>

<canvas id="canvas" width="1400" height="950"></canvas>    

<script>
    var canvas = document.getElementById('canvas')
    var ctx = canvas.getContext("2d");
    ctx.translate(10, -10);

    //Utils--------------------------------------------------------------------
    function circle(x, y, r, doOutline) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, 2*Math.PI, false);
        ctx.fill();
        if (doOutline) ctx.stroke();
    }
    function line(x, y, x2, y2) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
    function Wheel (x, y, rad, rot, minRotDeg) {
        this.x = x;
        this.y = y;
        
        this.rad = rad;
        this.rot = rot;

        this.minRotDeg = minRotDeg;

        this.updatePivot = ()=>{
            this.pivotX = this.x+Math.cos(this.rot)*this.rad;
            this.pivotY = this.y+Math.sin(this.rot)*this.rad;
        }
        this.updatePivot();
    }

    //Constants----------------------------------------------------------------
    const W = 1400;
    const H = 950;

    const pxPerMM = 1400/500;
    const shelfDepth_mm = 60;
    const pivotRad_px = 15;

    const PI = Math.PI;
    const linkageW_px = 20;

    const targetX = shelfDepth_mm-25/2;
    const targetYPoints = [25/2, 182+25/2, 224+25/2, 266+25/2];

    var targetScores = [999, 999, 999, 999];
    var prevSystemScore = 999;
    var stopIterating = false;

    //System Variables----------------------------------------------------------------
    function System (wheel1, wheel2, lengthA, lengthB, lengthBTotal) {
        this.wheel1 = wheel1;
        this.wheel2 = wheel2;
        this.lengthA = lengthA;
        this.lengthB = lengthB;
        this.lengthBTotal = lengthBTotal;
    }

    // var bestSystem = new System(new Wheel(350, 100, 30, 0), new Wheel(400, 150, 30, 0), 100, 60, 300);
    // var bestSystem = new System(new Wheel(378, 147, 73.5, 0), new Wheel(391, 109, 42, 0), 99, 64, 331);
    var bestSystem = new System(new Wheel(351-20, 116.6, 30, 0, 110), new Wheel(426-20, 136.9, 36.6, 0, 45), 91, 48.9, 300);

    function getRandom() {
        return (Math.random()-0.5)*15;
    }
    function clamp(x, min, max) {
        return Math.max(Math.min(x, max), min);
    }

    function mutateSystem(system) {
        system.wheel1.x += getRandom();
        system.wheel1.y += getRandom();
        system.wheel1.rad += getRandom();
        system.wheel1.minRotDeg += getRandom();
        system.wheel2.x += getRandom();
        system.wheel2.y += getRandom();
        system.wheel2.rad += getRandom();
        system.wheel2.minRotDeg += getRandom();

        system.lengthA += getRandom();
        system.lengthB += getRandom();
        system.lengthBTotal += getRandom();

        system.wheel1.rad = clamp(system.wheel1.rad, 30, 150)
        system.wheel2.rad = clamp(system.wheel2.rad, 30, 150)
        system.lengthA = clamp(system.lengthA, 30, 200)
        system.lengthB = clamp(system.lengthB, 30, 200)
        system.lengthBTotal = clamp(system.lengthBTotal, 30, 1000)
    }

    function iterateSystem(system) {
        ctx.clearRect(0, 0, W, H);

        for(system.wheel1.rot = 0; system.wheel1.rot <= PI*2; system.wheel1.rot += 0.1) {
            for(system.wheel2.rot = 0; system.wheel2.rot <= PI*2; system.wheel2.rot += 0.1) {
                updateKinematics(system);
                renderSystem(system);
            }
        }
    }

    function scoreLastIteratedSystem(system) {
        return targetScores.reduce((acc, curr) => acc + curr, 0);
    }

    function stop() {
        stopIterating = true;
        setTimeout(() => {
            iterateSystem(bestSystem);
            console.log(bestSystem);
        }, 1000);
    }

    //Kinematic References
    function updateKinematics (sys) {
        sys.wheel1.updatePivot();
        sys.wheel2.updatePivot();

        let c = Math.hypot(sys.wheel1.pivotX-sys.wheel2.pivotX, sys.wheel1.pivotY-sys.wheel2.pivotY);
        let thetaInterior = Math.acos((sys.lengthB*sys.lengthB-sys.lengthA*sys.lengthA-c*c)/(-2*sys.lengthA*c)); 
        let thetaReference = Math.atan2(sys.wheel1.pivotY-sys.wheel2.pivotY, sys.wheel1.pivotX-sys.wheel2.pivotX);
        let thetaLinkage = thetaReference-thetaInterior;
        sys.linkagePivotX = sys.wheel2.pivotX+Math.cos(thetaLinkage)*sys.lengthA;
        sys.linkagePivotY = sys.wheel2.pivotY+Math.sin(thetaLinkage)*sys.lengthA;

        sys.linkageEndpointX = sys.wheel2.pivotX+Math.cos(thetaLinkage)*sys.lengthBTotal;
        sys.linkageEndpointY = sys.wheel2.pivotY+Math.sin(thetaLinkage)*sys.lengthBTotal;

        for(let y in targetYPoints) {
            if (isNaN(sys.linkageEndpointX+sys.linkageEndpointY)) return;
            
            targetScores[y] = Math.min(targetScores[y], Math.hypot(sys.linkageEndpointX-targetX, sys.linkageEndpointY-targetYPoints[y]));
        }
    }

    //Drawing------------------------------------------------------------------
    function renderSystem(sys) {
        // ctx.clearRect(0, 0, W, H);

        ctx.strokeStyle = "brown";
        ctx.lineWidth = 2*pxPerMM;
        line(0, H, 0, H-264*pxPerMM)
        line(0, H, shelfDepth_mm*pxPerMM, H)
        line(0, H-181*pxPerMM, shelfDepth_mm*pxPerMM, H-181*pxPerMM)
        line(0, H-223*pxPerMM, shelfDepth_mm*pxPerMM, H-223*pxPerMM)
        line(0, H-264*pxPerMM, shelfDepth_mm*pxPerMM, H-264*pxPerMM)

        ctx.strokeStyle = "black";
        ctx.fillStyle = "red";
        circle(sys.wheel1.x*pxPerMM, H-sys.wheel1.y*pxPerMM, sys.wheel1.rad*pxPerMM, true);
        ctx.fillStyle = "green";
        circle(sys.wheel2.x*pxPerMM, H-sys.wheel2.y*pxPerMM, sys.wheel2.rad*pxPerMM, true);

        ctx.strokeStyle = "gray";
        ctx.lineWidth = linkageW_px;
        // line(sys.wheel2.pivotX*pxPerMM, H-sys.wheel2.pivotY*pxPerMM, sys.linkageEndpointX*pxPerMM, H-sys.linkageEndpointY*pxPerMM);
        line(sys.wheel1.pivotX*pxPerMM, H-sys.wheel1.pivotY*pxPerMM, sys.linkagePivotX*pxPerMM, H-sys.linkagePivotY*pxPerMM);
        
        ctx.lineWidth = 2*pxPerMM;
        ctx.strokeStyle = "black";
        ctx.fillStyle = "lightgray";
        circle(sys.wheel1.pivotX*pxPerMM, H-sys.wheel1.pivotY*pxPerMM, pivotRad_px, true);
        circle(sys.wheel2.pivotX*pxPerMM, H-sys.wheel2.pivotY*pxPerMM, pivotRad_px, true);
        circle(sys.linkagePivotX*pxPerMM, H-sys.linkagePivotY*pxPerMM, pivotRad_px, true);
        circle(sys.linkageEndpointX*pxPerMM, H-sys.linkageEndpointY*pxPerMM, pivotRad_px, true);

        ctx.fillStyle = "lime";
        for(let y in targetYPoints) {
            circle(targetX*pxPerMM, H-targetYPoints[y]*pxPerMM, 25/2*pxPerMM, true);
        }
    }

    // setInterval(() => {
    //     bestSystem.wheel1.rot += 0.1;
    //     bestSystem.wheel2.rot -= 0.01;
    //     // iterateSystem(bestSystem);
    //     updateKinematics(bestSystem);
    //     renderSystem(bestSystem);
    // }, 20)

    iterateSystem(bestSystem);
    prevSystemScore = scoreLastIteratedSystem();
    console.log("Initial Score: " + prevSystemScore);
    
    function evolve () {
        let mutatedSystem = {...bestSystem};
        mutateSystem(mutatedSystem);
        iterateSystem(mutatedSystem);
        if (scoreLastIteratedSystem() < prevSystemScore) {
            prevSystemScore = scoreLastIteratedSystem();
            bestSystem = mutatedSystem;
            console.log("New Score: " + prevSystemScore);
        } else {
            console.log("No Improvement");
        }
        if (!stopIterating) setTimeout(evolve, 0);
    }
    evolve();
</script>